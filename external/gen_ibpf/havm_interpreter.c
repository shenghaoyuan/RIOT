#include "havm_interpreter.h"

static __attribute__((always_inline)) inline _Bool check_pc (struct havm_state* st) {
  return (*st).pc_loc < (*st).input_len;
}
static __attribute__((always_inline)) inline _Bool check_pc_incr(struct havm_state* st) {
  return (*st).pc_loc+1 < (*st).input_len;
}

static __attribute__((always_inline)) inline void upd_pc(struct havm_state* st, unsigned int pc) {
  (*st).pc_loc += pc;
  return ;
}


static __attribute__((always_inline)) inline unsigned int eval_reg(struct havm_state* st, unsigned int i){
  return (*st).regsmap[i];
}

static __attribute__((always_inline)) inline void upd_reg (struct havm_state* st, unsigned int i, unsigned int v){
  (*st).regsmap[i] = v;
  return ;
}

static __attribute__((always_inline)) inline unsigned eval_flag(struct havm_state* st){
  return (*st).bpf_flag;
}

static __attribute__((always_inline)) inline void upd_flag(struct havm_state* st, unsigned f){
  (*st).bpf_flag = f;
  return ;
}

static __attribute__((always_inline)) inline unsigned int eval_mrs_num(struct havm_state* st){
  return (*st).mrs_num;
}

static __attribute__((always_inline)) inline struct memory_region *eval_mrs_regions(struct havm_state* st){
  return (*st).mrs;
}

/*
void add_mem_region(struct havm_state* st, struct memory_region* mr){
  (*st).mrs[(*st).mem_num] = *mr;
  (*st).mem_num += 1;
  return ;
}

void add_mem_region_ctx(struct havm_state* st, struct memory_region* mr){
  (*st).mrs[0] = *mr;
  (*st).mem_num = 1;
  return ;
} */

static __attribute__((always_inline)) inline unsigned int load_mem(struct havm_state* st, unsigned int chunk, unsigned char* addr){
  /*if (addr == 0U) {
    (*st).bpf_flag = BPF_ILLEGAL_MEM; return ;
  }
  else{*/
    switch (chunk) {
      case 1: return *(unsigned char *) addr;
      case 2: return *(unsigned short *) addr;
      case 4: return *(unsigned int *) addr;
      default: /*printf ("load:addr = %" PRIu64 "\n", v); (*st).bpf_flag = BPF_ILLEGAL_MEM;*/ return 0LLU;
    }
  //}
}

static __attribute__((always_inline)) inline void store_mem(struct havm_state* st, unsigned char* addr, unsigned int chunk, unsigned int v){
  /*if (addr == 0U) {
    (*st).bpf_flag = BPF_ILLEGAL_MEM; return ;
  }
  else{*/
    switch (chunk) {
      case 1: *(unsigned char *) addr = v; return ;
      case 2: *(unsigned short *) addr = v; return ;
      case 4: *(unsigned int *) addr = v; return ;
      default: /*printf ("store_imm:addr = %" PRIu64 "\n", addr); (*st).bpf_flag = BPF_ILLEGAL_MEM;*/ return ;
    }
  //}
}

static __attribute__((always_inline)) inline unsigned long long eval_ins(struct havm_state* st)
{
  return *((*st).input_ins + (*st).pc_loc);
}

static __attribute__((always_inline)) inline _Bool cmp_ptr32_nullM(unsigned char* addr){
   return (addr == 0);
}

static __attribute__((always_inline)) inline unsigned int get_dst(unsigned long long ins)
{
  return (unsigned int) ((ins & 4095LLU) >> 8LLU);
}

static __attribute__((always_inline)) inline unsigned int get_src(unsigned long long ins)
{
  return (unsigned int) ((ins & 65535LLU) >> 12LLU);
}

static __attribute__((always_inline)) inline struct memory_region *get_mem_region(unsigned int n, struct memory_region *mrs)
{
  return mrs + n;
}

/*
static __attribute__((always_inline)) inline unsigned int eval_key_value2_alu32_ofs(struct havm_state* st){
  return (*st).tp_kv[(*st).pc_loc].alu32_ofs;
} */

static __attribute__((always_inline)) inline void jit_call(struct havm_state* st){
  //_magic_function is user-defined or compcert build-in
  // for user-defined, we swapped the order to make sure r0 is the start address of jitted_list while r1 is the start address of jit_state.
  unsigned int ofs;
  ofs = (*st).tp_kv[(*st).pc_loc].arm_ofs; //printf("pc1 = %d ofs = %d\n", (*st).pc_loc, 4*ofs);
  _magic_function(ofs, st); //printf("pc1 = %d\n", (*st).pc_loc);
  (*st).pc_loc += (*st).tp_kv[(*st).pc_loc].alu32_ofs; //printf("pc2 = %d\n", (*st).pc_loc);
  return ;
}

static __attribute__((always_inline)) inline unsigned char *_bpf_get_call(int imm) {
  /* deleting `return NULL;` and adding your system APIs
  switch (imm) {
    default: return ...
  }
  */
  return NULL;
}

static __attribute__((always_inline)) inline unsigned int exec_function(struct havm_state* st, unsigned char * ptr){
  if (ptr == 0){
    (*st).bpf_flag = vBPF_ILLEGAL_CALL;
    return 0U;
  }
  else {
    /**do something e.g. print; */
    return 0U;
  }
}

/*******************below code are automatically generated by dx (after repatch) ***************************/

static __attribute__((always_inline)) inline int get_offset(unsigned long long ins)
{
  return (int) (short) (ins << 32LLU >> 48LLU);
}

static __attribute__((always_inline)) inline int get_immediate(unsigned long long ins)
{
  return (int) (ins >> 32LLU);
}

static __attribute__((always_inline)) inline unsigned int get_src32(struct havm_state* st, unsigned char x, unsigned long long ins)
{
  int imm;
  unsigned int src;
  if (0U == (x & 8U)) {
    imm = get_immediate(ins);
    return imm;
  } else {
    src = get_src(ins);
    return eval_reg(st, src);
  }
}

static __attribute__((always_inline)) inline unsigned char get_opcode_ins(unsigned long long ins)
{
  return (unsigned char) (ins & 255LLU);
}

static __attribute__((always_inline)) inline unsigned char get_opcode_alu32(unsigned char op)
{
  return (unsigned char) (op & 240);
}

static __attribute__((always_inline)) inline unsigned char get_opcode_branch(unsigned char op)
{
  return (unsigned char) (op & 240);
}

static __attribute__((always_inline)) inline unsigned char get_opcode_mem_ld_reg(unsigned char op)
{
  return (unsigned char) (op & 255);
}

static __attribute__((always_inline)) inline unsigned char get_opcode_mem_st_imm(unsigned char op)
{
  return (unsigned char) (op & 255);
}

static __attribute__((always_inline)) inline unsigned char get_opcode_mem_st_reg(unsigned char op)
{
  return (unsigned char) (op & 255);
}

static __attribute__((always_inline)) inline unsigned char get_opcode_nat(unsigned char op)
{
  return (unsigned char) (op & 7);
}

static __attribute__((always_inline)) inline unsigned int get_add(unsigned int x, unsigned int y)
{
  return x + y;
}

static __attribute__((always_inline)) inline unsigned int get_sub(unsigned int x, unsigned int y)
{
  return x - y;
}

static __attribute__((always_inline)) inline unsigned int get_addr_ofs(unsigned int x, int ofs)
{
  return x + ofs;
}

static __attribute__((always_inline)) inline unsigned int get_start_addr(struct memory_region *mr)
{
  return (*mr).start_addr;
}

static __attribute__((always_inline)) inline unsigned int get_block_size(struct memory_region *mr)
{
  return (*mr).block_size;
}

static __attribute__((always_inline)) inline unsigned int get_block_perm(struct memory_region *mr)
{
  return (*mr).block_perm;
}

static __attribute__((always_inline)) inline unsigned char *check_mem_aux2(struct memory_region *mr, unsigned int perm, unsigned int addr, unsigned int chunk)
{
  unsigned int start;
  unsigned int size;
  unsigned int mr_perm;
  unsigned int lo_ofs;
  unsigned int hi_ofs;
  start = get_start_addr(mr);
  size = get_block_size(mr);
  mr_perm = get_block_perm(mr);
  lo_ofs = get_sub(addr, start);
  hi_ofs = get_add(lo_ofs, chunk);
  if (hi_ofs <= size
        && (lo_ofs <= 4294967295U - chunk && 0U == lo_ofs % chunk)
        && mr_perm >= perm) {
    return (*mr).block_ptr + lo_ofs;
  } else {
    return 0;
  }
}

static __attribute__((always_inline)) inline unsigned char *check_mem_aux(struct havm_state* st, unsigned int num, unsigned int perm, unsigned int chunk, unsigned int addr, struct memory_region *mrs)
{
  unsigned int n;
  struct memory_region *cur_mr;
  unsigned char *check_ptr;
  _Bool is_null;
  if (num == 0U) {
    return 0;
  } else {
    n = num - 1U;
    cur_mr = get_mem_region(n, mrs);
    check_ptr = check_mem_aux2(cur_mr, perm, addr, chunk);
    is_null = cmp_ptr32_nullM(check_ptr);
    if (is_null) {
      return check_mem_aux(st, n, perm, chunk, addr, mrs);
    } else {
      return check_ptr;
    }
  }
}

unsigned char *check_mem(struct havm_state* st, unsigned int perm, unsigned int chunk, unsigned int addr)
{
  unsigned int mem_reg_num;
  struct memory_region *mrs;
  unsigned char *check_ptr;
  _Bool is_null;
  mem_reg_num = eval_mrs_num(st);
  mrs = eval_mrs_regions(st);
  check_ptr =
    check_mem_aux(st, mem_reg_num, perm, chunk, addr, mrs);
  is_null = cmp_ptr32_nullM(check_ptr);
  if (is_null) {
    return 0;
  } else {
    return check_ptr;
  }
}

static __attribute__((always_inline)) inline void step_opcode_branch(struct havm_state* st, unsigned int dst32, unsigned int src32, unsigned int ofs, unsigned char op)
{
  unsigned char opcode_jmp;
  unsigned char *f_ptr;
  _Bool is_null;
  unsigned int res;
  opcode_jmp = get_opcode_branch(op);
  switch (opcode_jmp) {
    case 0:
      if (op == 5) {
        upd_pc(st, ofs);
        return;
      } else {
        upd_flag(st, 2U);
        return;
      }
    case 16:
      if (dst32 == src32) {
        upd_pc(st, ofs);
        return;
      } else {
        return;
      }
    case 32:
      if (dst32 > src32) {
        upd_pc(st, ofs);
        return;
      } else {
        return;
      }
    case 48:
      if (dst32 >= src32) {
        upd_pc(st, ofs);
        return;
      } else {
        return;
      }
    case 160:
      if (dst32 < src32) {
        upd_pc(st, ofs);
        return;
      } else {
        return;
      }
    case 176:
      if (dst32 <= src32) {
        upd_pc(st, ofs);
        return;
      } else {
        return;
      }
    case 64:
      if ((dst32 & src32) != 0U) {
        upd_pc(st, ofs);
        return;
      } else {
        return;
      }
    case 80:
      if (dst32 != src32) {
        upd_pc(st, ofs);
        return;
      } else {
        return;
      }
    case 96:
      if ((int) dst32 > (int) src32) {
        upd_pc(st, ofs);
        return;
      } else {
        return;
      }
    case 112:
      if ((int) dst32 >= (int) src32) {
        upd_pc(st, ofs);
        return;
      } else {
        return;
      }
    case 192:
      if ((int) dst32 < (int) src32) {
        upd_pc(st, ofs);
        return;
      } else {
        return;
      }
    case 208:
      if ((int) dst32 <= (int) src32) {
        upd_pc(st, ofs);
        return;
      } else {
        return;
      }
    case 128:
      if (op == 133) {
        f_ptr = _bpf_get_call((int) src32);
        is_null = cmp_ptr32_nullM(f_ptr);
        if (is_null) {
          upd_flag(st, 5U);
          return;
        } else {
          res = exec_function(st, f_ptr);
          upd_reg(st, 0U, res);
          return;
        }
      } else {
        upd_flag(st, 2U);
        return;
      }
    case 144:
      if (op == 149) {
        upd_flag(st, 1U);
        return;
      } else {
        upd_flag(st, 2U);
        return;
      }
    default:
      upd_flag(st, 2U);
      return;
    
  }
}

static __attribute__((always_inline)) inline void step_opcode_mem_ld_reg(struct havm_state* st, unsigned int addr, unsigned int dst, unsigned char op)
{
  unsigned char opcode_ld;
  unsigned char *addr_ptr;
  _Bool is_null;
  unsigned int v;
  opcode_ld = get_opcode_mem_ld_reg(op);
  switch (opcode_ld) {
    case 97:
      addr_ptr = check_mem(st, 1U, 4U, addr);
      is_null = cmp_ptr32_nullM(addr_ptr);
      if (is_null) {
        upd_flag(st, 3U);
        return;
      } else {
        v = load_mem(st, 4U, addr_ptr);
        upd_reg(st, dst, v);
        return;
      }
    case 105:
      addr_ptr = check_mem(st, 1U, 2U, addr);
      is_null = cmp_ptr32_nullM(addr_ptr);
      if (is_null) {
        upd_flag(st, 3U);
        return;
      } else {
        v = load_mem(st, 2U, addr_ptr);
        upd_reg(st, dst, v);
        return;
      }
    case 113:
      addr_ptr = check_mem(st, 1U, 1U, addr);
      is_null = cmp_ptr32_nullM(addr_ptr);
      if (is_null) {
        upd_flag(st, 3U);
        return;
      } else {
        v = load_mem(st, 1U, addr_ptr);
        upd_reg(st, dst, v);
        return;
      }
    default:
      upd_flag(st, 2U);
      return;
    
  }
}

static __attribute__((always_inline)) inline void step_opcode_mem_st_imm(struct havm_state* st, int imm, unsigned int addr, unsigned char op)
{
  unsigned char opcode_st;
  unsigned char *addr_ptr;
  _Bool is_null;
  opcode_st = get_opcode_mem_st_imm(op);
  switch (opcode_st) {
    case 98:
      addr_ptr = check_mem(st, 2U, 4U, addr);
      is_null = cmp_ptr32_nullM(addr_ptr);
      if (is_null) {
        upd_flag(st, 3U);
        return;
      } else {
        store_mem(st, addr_ptr, 4U, (unsigned int) imm);
        return;
      }
    case 106:
      addr_ptr = check_mem(st, 2U, 2U, addr);
      is_null = cmp_ptr32_nullM(addr_ptr);
      if (is_null) {
        upd_flag(st, 3U);
        return;
      } else {
        store_mem(st, addr_ptr, 2U, (unsigned int) imm);
        return;
      }
    case 114:
      addr_ptr = check_mem(st, 2U, 1U, addr);
      is_null = cmp_ptr32_nullM(addr_ptr);
      if (is_null) {
        upd_flag(st, 3U);
        return;
      } else {
        store_mem(st, addr_ptr, 1U, (unsigned int) imm);
        return;
      }
    default:
      upd_flag(st, 2U);
      return;
    
  }
}

static __attribute__((always_inline)) inline void step_opcode_mem_st_reg(struct havm_state* st, unsigned int src32, unsigned int addr, unsigned char op)
{
  unsigned char opcode_st;
  unsigned char *addr_ptr;
  _Bool is_null;
  opcode_st = get_opcode_mem_st_reg(op);
  switch (opcode_st) {
    case 99:
      addr_ptr = check_mem(st, 2U, 4U, addr);
      is_null = cmp_ptr32_nullM(addr_ptr);
      if (is_null) {
        upd_flag(st, 3U);
        return;
      } else {
        store_mem(st, addr_ptr, 4U, src32);
        return;
      }
    case 107:
      addr_ptr = check_mem(st, 2U, 2U, addr);
      is_null = cmp_ptr32_nullM(addr_ptr);
      if (is_null) {
        upd_flag(st, 3U);
        return;
      } else {
        store_mem(st, addr_ptr, 2U, src32);
        return;
      }
    case 115:
      addr_ptr = check_mem(st, 2U, 1U, addr);
      is_null = cmp_ptr32_nullM(addr_ptr);
      if (is_null) {
        upd_flag(st, 3U);
        return;
      } else {
        store_mem(st, addr_ptr, 1U, src32);
        return;
      }
    default:
      upd_flag(st, 2U);
      return;
    
  }
}

static __attribute__((always_inline)) inline void step(struct havm_state* st)
{
  unsigned long long ins;
  unsigned char op;
  unsigned char opc;
  unsigned int dst;
  unsigned int dst32;
  int ofs;
  unsigned int src32;
  unsigned int src;
  unsigned int addr;
  //unsigned int ofs1;
  int imm;
  ins = eval_ins(st);
  op = get_opcode_ins(ins);
  opc = get_opcode_nat(op);
  dst = get_dst(ins);
  switch (opc) {
    case 4:
      jit_call(st);
      return;
    case 5:
      dst32 = eval_reg(st, dst);
      ofs = get_offset(ins);
      src32 = get_src32(st, op, ins);
      step_opcode_branch(st, dst32, src32, (unsigned int) ofs,
                         op);
      return;
    case 1:
      src = get_src(ins);
      src32 = eval_reg(st, src);
      ofs = get_offset(ins);
      addr = get_addr_ofs(src32, ofs);
      step_opcode_mem_ld_reg(st, addr, dst, op);
      return;
    case 2:
      dst32 = eval_reg(st, dst);
      ofs = get_offset(ins);
      imm = get_immediate(ins);
      addr = get_addr_ofs(dst32, ofs);
      step_opcode_mem_st_imm(st, imm, addr, op);
      return;
    case 3:
      dst32 = eval_reg(st, dst);
      src = get_src(ins);
      src32 = eval_reg(st, src);
      ofs = get_offset(ins);
      addr = get_addr_ofs(dst32, ofs);
      step_opcode_mem_st_reg(st, src32, addr, op);
      return;
    default:
      upd_flag(st, 2U);
      return;
    
  }
}

static __attribute__((always_inline)) inline void bpf_interpreter_aux(struct havm_state* st, unsigned int fuel)
{
  unsigned int fuel0;
  _Bool b0;
  unsigned int f;
  _Bool b1;
  if (fuel == 0U) {
    upd_flag(st, 6U);
    return;
  } else {
    fuel0 = fuel - 1U;
    b0 = check_pc(st);
    if (b0) {  //printf("pc=%d\n", (*st).pc_loc);
      step(st); //print_havm_state(st);
      //printf("pc_after=%d\n", (*st).pc_loc);
      f = eval_flag(st);
      if (f == 0U) {
        b1 = check_pc_incr(st);
        if (b1) {
          upd_pc(st, 1U);
          bpf_interpreter_aux(st, fuel0);
          return;
        } else { //printf("222=%d\n", (*st).pc_loc);
          upd_flag(st, 6U);
          return;
        }
      } else {
        return;
      }
    } else {
      upd_flag(st, 6U);
      return;
    }
  }
}

unsigned int havm_interpreter(struct havm_state* st, unsigned int fuel, unsigned int ctx_ptr)
{
  unsigned int f;
  unsigned int res;
  upd_reg(st, 1U, ctx_ptr);
  bpf_interpreter_aux(st, fuel);
  f = eval_flag(st);
  if (f == 1U) {
    res = eval_reg(st, 0U);
    return res;
  } else {
    return 0U;
  }
}

